надежность pragma ^0.5.7;

импорт "./ERC20Standard.sol";

контракт NewToken является стандартом ERC20 {
 конструктор() общедоступный {
 Общее предложение = 12300000;
 название = "MAMYcoin";
 десятичные дроби = 4;
 символ = "MAM";
 версия = "1.0";
 остатки[msg.отправитель] = Общее количество;
	}
}
надежность pragma ^0.5.7;

безопасный путь в библиотеку {

    функция mul(uint256 a, uint256 b) внутренние чистые возвраты (uint256) {
        если (a == 0) {
            возврат 0;
        }

        uint256 c = a * b;
        требуется(c / a == b);

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;
        
	return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}

contract ERC20Standard {
	using SafeMath for uint256;
	uint public totalSupply;
	
	string public name;
	uint8 public decimals;
	string public symbol;
 публичная версия строки;
	
 сопоставление (адрес => uint256) балансов;
 сопоставление (адрес => сопоставление (адрес =>> uint)) разрешено;

 //Исправлена ошибка для атаки с коротким адресом против ERC20
 модификатор onlyPayloadSize(размер uint) {
 утверждение(msg.data.длина == размер + 4);
		_;
	} 

 функция balanceOf(адрес _owner) возвращает публичное представление (баланс uint) {
 возвратные остатки [_владелец];
	}

 передача функций(адрес _реципиент, uint _ значение) общедоступный только размер загрузки(2*32) {
 требуется(баланс[msg.отправитель] > = _ значение & & _ значение >> 0);
 остатки[msg.отправитель] = остатки[msg.отправитель].sub (_значение);
 остатки[_recipient] = остатки[_recipient].добавить (_значение);
 передача эмиссии(msg.отправитель, _реципиент, _ значение); 
        }

 функция transferFrom(адрес _from, адрес _to, uint _ значение) общедоступная {
 требуется(балансы[_from] > = _ значение && разрешено[_from][msg.отправитель] > > = _ значение & & _ значение >>> 0);
 остатки[_to] = остатки[_to].добавить (_значение);
 остатки[_from] = остатки[_from].sub (_значение);
 разрешено[_from][msg.отправитель] = разрешено[_from][msg.отправитель].sub (_значение);
 передача эмиссии (_из, _ в, _ значение);
        }

 функция одобрить(адрес _spender, uint _ значение) общедоступная {
 разрешено[msg.отправитель][_spender] = _ значение;
		emit Approval(msg.sender, _spender, _value);
	}

	надбавка за функцию(адрес_спендер , адрес_владелец )   возвращает публичное представление ( баланс uint) {
		возврат разрешен [_владелец] [_транжира];
	}

	//Событие, которое запускается для регистрации всех переводов в журнале событий этого контракта
	передача событий(
		адрес , индексированный из ,
		адрес проиндексирован_то ,
 uint _ значение
		);
		
	//Событие, которое запускается всякий раз, когда владелец утверждает новое пособие для транжиры.
	утверждение события(
		адрес , индексированный владельцем ,
		адрес индексированный_спендер ,
 uint _ значение
		);
}
